<!DOCTYPE html>
<html lang="es-Es">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Guia Basica | Git y GitHub</title>
        <link href="https://unpkg.com/ionicons@4.5.10-0/dist/css/ionicons.min.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap" rel="stylesheet">
        <script src="https://kit.fontawesome.com/2c36e9b7b1.js" crossorigin="anonymous"></script>
        <link rel="stylesheet" type="text/css" href="css/style.css">
        <link rel="shortcut icon" href="img/git.png" type="image/x-icon">
        
    </head>
    <body>
        <!--Inicio de la cabecera-->
        <header class="header">
            <div class="container logo-nav-container">
                <a href="#" class="logo">Guía Básica de Git y GitHub</a>
                <!--<span class="menu-icon">Ver menú</span>
                Menu de navegacion
                <nav class="navegation">
                    <ul class="show">
                        <li>
                            <a href="index.html">Inicio</a>
                        </li>
                        <li>
                            <a href="index.html">Servicios</a>
                        </li>
                        <li>
                            <a href="index.html">Proyectos</a>
                        </li>
                        <li>
                            <a href="index.html">Contacto</a>
                        </li>
                    </ul>
                </nav>-->
                <button class="switch" id="switch">
                    <span><i class="fas fa-sun"></i></span>
                    <span><i class="fas fa-moon"></i></span>
                </button>
            </div>
        </header>
        <!--Fin de la cabecera-->
        <main class="main">
            <div class="container">
                <h1>Comandos del dia a dia con Git y GitHub</h1>
                <hr>
                <h3>Crear un repositorio nuevo:</h3>
                <ol>
                    <li>Crea un directorio nuevo, abrelo y ejecutalo</li>
                    <li>Utiliza el comando $git init</li>
                </ol>
                <h3>Una lista que no puedes olvidar</h3>
                <ul>
                    <li class="block-create code p">$git status</li>
                    <dt>Muestra el estado de actual de los archivos ubicados en el área de staging</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git commit -m "descripcion commit"</li>
                    <dt>Agrega los cambios a la BD del repositorio de git</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git commit -am "Descripción commit"</li>
                    <dt>Nos ahorra el tener que utilizar git commit ., este comando solo es válido para archivos que ya existen en el repositorio, no afectará a archivos nuevos que no hayan sido agregados con $ git add</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git commit</li>
                    <dt>Abrirá el editor Vim para poder agregar un comentario, siempre es obligatorio agregar un comentario para el commit. Para poder editar el comit usar "ESC i". Para guardar cambios ESC + SHIFT + Z Z</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git log</li>
                    <dt>Muestra el historial detallado con commit e id, de todos los commits en dicho repositorio</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git log (repotenciado)</li>
                    <dt> Para tener una visualización más gráfica de tu historial en un repositorio, puedes usar el comando $git log --all -decorate- oneline con esto, podrás ver el historial de cambios y ramas de forma más gráfica.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git log para buscar</li>
                    <dt>si deseas buscar palabras que hayas dejado en tus commits, puedes usar git log -S palabra, esto te retornará todos los commits que incluyan la palabra a buscar.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git diff</li>
                    <dt>Permite ver las diferencias entre el staging y nuestro archivo en local. tiene las variaciones git diff id1 id2 donde se comparan dos versiones según los id del commit seleccionado. y git diff --stat donde ves las diferencias más resumidas.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git show</li>
                    <dt>Se utiliza para ver el commit y la rama en el que te encuentras actualmente.
                    </dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git greep</li>
                    <dt> se usa para buscar texto en nuestros archivos del repositorio, puedes ver la cantidad de veces que se usa una palabra, incluso incluir expresiones regulares. Un ejemplo sería usar git gre -n palabra para ver en que archivos y que líneas esta la palabra "palabra" o git grep -c palabra para ver la cantidad de veces que se repite la palabra "palabra"</dt>
                </ul>
                <h3>Comandos de configuración</h3>
                <ul>
                    <li class="block-create code p">$git config --global user.name "Nombre"</li>
                    <dt>Configura nombre usuario</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git config --global user.email "email"</li>
                    <dt>Configura email de usuario</dt>
                </ul>
                <h3>Comandos de consola</h3>
                <p>Esta sección es un extra, no tiene que ver directamente con Git, pero puede apoyar de una u otra manera tu repositorios.</p>
                <ul>
                    <li><strong>Crear un alias</strong></li>
                    <dt>Para resumir comandos que sean muy extensos, se puede utilizar el comando alias nombreNuevoComando="Comando a convertir" de esta manera, podemos usar una palabra más fácil de recordar para nosotros.</dt>
                    <br>
                    <dd><strong>Ejemplo:</strong> alias arbolito="git log --all --graph --decorate --oneline"</dd>
                </ul>
                <h3>Comandos importantes</h3>
                <p>Estos comandos se separan ya que tienen funciones muy importantes.</p>
                <ul>
                    <li class="block-create code p">$git reset idCommit --hard/soft</li>
                    <dt>Este comando se encarga de regresar a una versión especificada. Se debe tener cuidado con este comando, ya que borrará absolutamente todos los cambios realizados despues de dicho commit. existen dos variastes para el mismo. --hard hará que regrese por completo todo a la versión elegida, perdiendo incluso, los cambios en staging. --soft cumple el mismo rol, pero mantiene los cambios en staging para su posterior commit.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git reset HEAD</li><strong>!Te lo recomiendo!</strong>
                    <br>
                    <dt>Regresa todos los cambios en staging como unstaged. Es decir, revierte el git add.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git checkout idCommit archivo.extension</li>
                    <dt>Obtiene la versión especificada de dicho archivo. PERO, no elimina sus versiones posteriores. La versión obtenida se tomará como untracked y podrá ser agregada al staging para realizar commit y crear una nueva versión.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git rm --cached</li>
                    <dt>Elimina los archivos del área de Staging y del próximo commit pero los mantiene en nuestro disco duro.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git rm --force</li>
                    <dt> Elimina los archivos del área de Staging y de nuestro disco duro.</dt>
                    <br>
                    <p>Para visualizar todo el historial de git, aunque lo hayamos eliminado, usamos el comando git reflog con este, podemos ver las referencias de los commit e ir y venir entre las distintas versiones con git RESET</p>
                    <p><strong>Recordatorio:</strong> ¡GIT RESET es una mala práctica! Solo usarlo en casos de extrema emergencia y como última opción.</p>
                </ul>
                <h3>Comandos en ramas</h3>
                <p>Estos son los comandos aplicados para manejarse entre ramas, crear nuevas ramas, etc.</p>
                <ul>
                    <li class="block-create code p">$git branch nameBranch</li>
                    <dt>Se utiliza para crear una nueva rama.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git checkout nameBranch</li>
                    <dt>Se utiliza para dirigirse hacia la rama elegida.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git branch -D nombreRama</li>
                    <dt>Se utiliza para eliminar ramas en git.</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git push origin nombreRama</li>
                    <dt>Se utiliza para enviar a un repositorio remoto la rama que hemos creado</dt>
                </ul>
                <ul>
                    <li class="block-create code p">$git merge nombreRama</li>
                    <dt>Este comando es súper importante, se utiliza cuando quieres unir los cambios entre 2 ramas.
                        Cuando tienes los cambios de una nueva que creaste y ya les hiciste commit, puedes hacer un merge para fusionarlos con tu rama de master. El proceso puede ser MASTER -> RAMA_NUEVA o RAMA_NUEVA -> MASTER. Cuando quieres dejar todo en master para tener todo en la rama principal, debe usar la segunda opción.</dt>
                </ul>
                <ul>
                    <li><strong>Conflictos</strong></li>
                    <dd> En GIT, los conflictos aparecen cuando existen diferencias en las mismas líneas de código de los archivos. Ya sea que un compañero modifico la misma línea de un archivo CSS que tú y tienen diferentes cosas.
                        Los conflictos son fáciles de solucionar y no debe generarte caos ni confusión. La consola de GIT te indicará el estatus del merge que intentaste realizar.</dd>
                </ul>
                <ul>
                    <li><strong>Auto-merging archivo.extension</strong></li>
                    <dt>indicará un merge correcto y CONFLICT (Content) archivo.extension indicará un conflicto.</dt>
                    <p><img src="https://i.imgur.com/4d9lsvn.jpg" width="100%" title="Hacer un checkout"></p>
                </ul>
                <p>Al revisar nuestro archivo en conflicto, encontraremos algo muy peculiar en el, GIT nos muestra exactamente cual fue la línea en conflictos y cuales son las diferencias entre nuestra rama actual y la que queremos obtener. Así se debe ver al usar el bloc de notas:</p>
                <p><img src="https://i.imgur.com/sG9xd61.jpg" width="100%" title="conflicto al hacer merge"></p>
                <br>
                <p>Debemos elegir entre el código que deseamos dejar en el repositorio y para esto, debemos comunicarnos con la persona que escribió el código (si es que estamos trabajando colaborativamente con alguien más) para decidir que código debe irse a la versión del merge. Posterior a este paso, se deben comentar la línea de "<<<<", las de "====" y las de ">>>>" junto con el código que no irá al repositorio.
                    Se deben guardar los cambios en el archivo y realizar un nuevo <strong>git add</strong> . además de un <strong>git commit -m "Comentario relacionado con la solución del conflicto en el merge"</strong></p>
                <ul>
                    <li><strong>Adicional</strong></li>
                    <dd>Si usas VSCode, podrás ver que el te da una sugerencia de que hacer con los cambios:</dd>
                    <p><img src="https://i.imgur.com/wqc6Z8n.jpg" width="100%" title="VSCode"></p>
                    <p>Si eliges Accept Current Change estarás dejando los cambios de la rama actual, en cambio, si elgies <strong>Accept Incoming Change</strong> estarás obteniendo los cambios de la rama desde la cual estás obteniendo los cambios</p>
                </ul>
                <ul>
                    <li><strong>Publicar ramas en repositorio remotos</strong></li>
                    <dt>Si deseas que tu rama pueda ser usada/visualizada por otros desarrolladores en un repositorio remoto, debes usar el comando <strong> git push origin nombreRama</strong></dt>
                </ul>
                <h3>Repositorios remotos en GitHub</h3>
                <p>Conoceremos como poder conectar nuestro repositorio local con algún repositorio remoto, subir nuestros cambios a dicho repositorio, obtener los cambios desde el repositorio y mucho más.</p>
                <p>Para este caso de prueba utilizaremos el repositorio remoto más conocido del mundo, GitHub.</p>
                
                <ol>
                    <li>Primero, debemos crearnos una cuenta en GitHub y crear un nuevo repositorio. Preferiblemente, debemos crear el archivo README ya que a través de el podremos indicarle a otros desarrolladores de que va nuestro código.</li>
                    <br>
                    <li>Luego de crear el repositorio, Github nos dará la url del mismo, esta la utilizaremos para agregar este origen remoto desde nuestro repositorio local. Se debe copiar la ruta HTTPS que github nos dió:</li>
                    <br>
                    <p><img src="https://i.imgur.com/yHnm1Y7.jpg" width="50%" title="crear el repositorio"></p>
                    <br>
                    <li>Usar el comando git remote add origin urlRepositorioRemoto con esto, estaremos agregando la referencia del repositorio remoto a nuestro repositorio en local. Posterior a esto, la consola de git no arrojará ningún mensaje, pero si usamos el comando git remove -v podremos visualizar el repositorio remoto al que hacemos referencia actualmente.</li>
                    <p><img src="https://i.imgur.com/F0Gt37L.jpg" width="100%" title="git remote"></p>
                    <p>Te dejo la url de este mismo repositorio para que puedas probar:<a href="https://github.com/sarleydurango/gitbasic-command.git">https://github.com/sarleydurango/gitbasic-command.git</a></p>
                    <br>
                    <li>Como ya tenemos la referencia del repositorio remoto, ahora debemos obtener la historia que se encuentre en dicho repositorio, esta acción se debe realizar siempre antes de enviar los cambios desde el repositorio local.</li>
                    <p>Si el repositorio remoto es diferente a nuestro repositorio local, es probable que Git nos de un warning con el mensaje "refusing to merge unrelated histories" esto quiere decir que no puede hacer la fusión debido a que las historias de los dos repositorios son diferentes. Para forzar esta acción y poder obtener la historia del repositorio remoto debemos usar el comando <strong> git pull origin master --allow-unrelated-histories</strong> para permitir unir ambas historias.</p>
                    <p><img src="https://i.imgur.com/jXyKWyQ.jpg" width="50%" title="git pull origin master"></p>
                    <li>Con el comando ls -al podremos ver el archivo README creado desde GitHub. Y al ejecutar git log también veremos el commit hecho en GitHub para dicho archivo.</li>
                    <p><img src="https://i.imgur.com/A6fLh4j.jpg" width="100%" title="Comandos ls"></p>
                    <li>Ahora, para subir los cambios locales al repositorio, debemos usar el comando git push origin master, con esto, ya nuestros cambios locales estarán dentro del repositorio remoto. Recordar siempre que este comando lo debemos ejecutar desde la rama master para no generar conflictos.</li>
                    <p><img src="https://i.imgur.com/QE64iWT.jpg" width="100%" title="Haciendo un git push"></p>
                    <br>
                    <p>Así quedó nuestro repositorio remoto en GitHub luego de agregar los cambios desde el repositorio local</p>
                    <p><img src="https://i.imgur.com/fHIKEhY.jpg" width="100%" title="Repositorio en GitHub"></p>

                </ol>
                <h3>Configurar tus llaves SSH en local</h3>
                <p>Aprenderemos como usar las llaves SSH para conectarnos a GitHub usando SSH y dejar a un lado HTTPS.</p>
                <p>Para hacer nuestra conexión aún más segura, podemos usar llaves encriptadas, con las cuales enviamos nuestros datos cifrados. Dichos datos solo podrán ser decifrados con una llave pública que compartiremos con GitHub.</p>
                <ol>
                    <li><strong>Primer paso:</strong> Generar las llaves SSH con el comando
                    <strong>ssh-keygen -t rsa -b 4096 -C "tu@email.com"</strong>
                        debemos usar el mismo email que usamos para Github. Tomar en cuenta que luego de apretar enter, nos va a sugerir agregarle una contraseña a dicha llave para hacerla aún más segura. Este paso es opcional, si no queremos agregarle una contraseña solo aprietas ENTER.</li>
                    <li><strong>Las llaves se guardaran en una carpeta oculta llamada .ssh</strong> donde tendremos la llave pública <strong>id_rsa.pub</strong> y la privada <strong>id_rsa</strong></li>
                    <p><strong> NOTA:</strong> La llave privada jamás se debe compartir con nadie ni con ningún otro dispositivo.</p>
                    <li><strong>Segundo paso:</strong> para terminar de configurar las claves, debemos comprobar que el servidor se encuentre activo, para esto usar el comando
                        eval $(ssh-agent -s)
                        lo cual nos debería retornar un mensaje Agent pid numeroAleatorio</li>
                    <li><strong>Tercer y último paso:</strong> ahora, solo debemos agregar al servidor nuestra llave privada, para esto, usar el comando
                        ssh-add ruta-donde-guardaste-tu-llave-privada
                        Y listo, ya tendremos configurada nuestra llave privada para poder conectarnos a través de SSH con GitHub</li>
                </ol>
                <h3>Conectarnos a Github a través de SSH</h3>
                <p>Luego de haber creado y configurado nuestra llave privada. Debemos configurar nuestra llave pública (la única que podemos compartir) con Github. Es importante tener en cuenta que debemos realizar los pasos anteriores, de lo contrario, no podremos continuar con este paso.</p>
                <ol>
                    <li>Como primer paso: debemos agregar nuestra llave pública a nuestra cuenta de Github. Para eso debemos copiar el contenido de nuestra llave publica, ubicada en el archivo id_rsa.pub</li>
                    <br>
                    <li>El segundo paso es: Ingresar en nuestra cuenta de Github y dirigirnos a la configuración y posteriormente a la gestion de KEYS SSH
                        url: https://github.com/settings/keys
                        Debemos hacer click en New SSH Key
                        </li>
                        <p><img src="https://i.imgur.com/QxiOehy.jpg" width="80%" title="Configurar llaves SSH"></p>
                        <p>y luego agregar como título, el pc que tendrá asignado dicha key publica, esto es para poder identificarlo, ya que podemos tener varios equipos conectados por SSH a nuestros repositorios. Al finalizar, hacer click en Add SSH KEY</p>
                        <p><img src="https://i.imgur.com/fWV5iWb.jpg" width="80%" title="Configurando llaves SSH"></p>
                        <li>Ahora podremos ver que nuestra key SSH se agregó correctamente</li>
                        <p><img src="https://i.imgur.com/r0K7wIg.jpg" width="80%" title="Configuración SSH terminada"></p>
                        <li>Como siguiente paso, debemos configurar nuestro repositorio local para dejar de usar HTTPS y empezar a usar SSH con nuestras nuevas keys. Para esto, debemos ir a nuestro repositorio y ejecutar el comando
                            git remote set-url origin url-ssh-del-repositorio-en-github
                            Con esto estaremos cambiando la url del repositorio en github. Podemos comprobar la nueva url usando git remove -v</li>
                        <li>Ahora puedes hacer un git pull origin master confirmar los mensajes, realizar cambios en tu repositorio local y hacer un git push origin master</li>

                </ol>
                <h3>Tags y versiones en Git y GitHub</h3>
                <p>Los tags nos permiten asignar versiones a los commits con cambios más importantes o significativos en nuestro proyecto. A continuación, se presentan los comandos para trabajar con las etiquetas:</p>
                <li><strong>Crear un tag:</strong> antes de crear un tag se debe elegir el commit el cual queremos identificar, para esto, podemos hacer un:
                    git log --all --graph --decorate --oneline o un git log --all --oneline y copiar el id del commit.       
                    Se usan los comandos anteriores para poder obtener el id más corto.
                    Luego, ejecutamos el comando para crear el tag git tag -a nombreDelTag -m "Comentario asociado al tag" idDelCommit</li>
                <li><strong>Visualizar tags creados:</strong> Para visualizar los tags que tenemos creados podemos usar los comandos git tag o git show-ref --tags con el primero, solo veremos el nombre del tag y con el segundo, podremos ver el commit generado al crear el tag y la ubicacion.</li>
                <li><strong>Enviar tags a un repositorio remoto:</strong> Para publicar nuestros tags se debe usar el comando git push origin --tags si te das cuenta, se hace diferente a publicar un commit común.</li>
                <li><strong>Eliminar tags:</strong> Los tags son publicados en Github como releases, versiones estables de nuestro código que deberían funcionar sin problemas. Si llegas a publicar un tag por equivocación, puedes borrarlo con los siguientes dos comandos:</li>
                <p>git tag -d nombreDelTag con esto estaremos borrando el tag en el repositorio local. Para eliminarlo del repositorio remoto se debe usar git push origin :refs/tags/nombreDelTag</p>
                <h3>Usando Rebase</h3>
                <p>Rebase se utiliza para unir los cambios que tengamos en una rama con nuestra rama master y no dejar rastros de la existencia de dicha rama creada.

                    El rebase es útil, por ejemplo, si estamos realizando arreglos de un bug y no se desean mostrar estos cambios como tomados de una rama, si no como parte del flujo normal de la aplicación.</p>
                <p>Rebase se encarga de ajustar los cambios al momento en que se realizaron y hacer un merge desde el primer commit, no desde el último (como funciona normalmente un flujo en git)</p>
                <li>Para hacer un rebase, primero debemos crear una nueva rama, posicionarnos en dicha rama con git checkout y realizar los cambios.</li>
                <li>Luego de tener nuestros cambios, debemos ejecutar el comando git rebase master desde nuestra rama de cambios es importante que git rebase se haga desde la rama con los cambios primero</li>
                <li>Con esto, ya tendremos unidas las historias de master con nuestra nueva rama. Posteior a esto se debe realizar checkout a mastery ejecutar el rebase desde master apuntando a nuestra rama de cambios git rebase nombreRamaCambios</li>
                <li>Esto lo que hará es integrar master con nuestra rama de cambios y luego pasarla a master nuevamente con todos los cambios incluidos, como un merge.</li>
                <li><strong>Nota:</strong> Usar rebase es una mala práctica, ya que no tenemos historia de lo que sucede, no se sabe quien hizo que cambios y en ocasiones, si master avanzó mucho, se pueden generar muchos conflictos.</li>
                <h3>Usando Git Stash</h3>
                <p>Git stash es muy útil cuando tienes cambios que no deseas realizarle commits aún, o para realizar pruebas, experimentos que no requieran o no quieras crear una rama para poder visualizarlos</p>
                <p>El stash es una forma de almacenar tus cambios pendientes para luego poder obtenerlos y hacerles commit, incluso puedes crear una rama con esos cambios pendientes, hacerle commit en la nueva rama y luego realizar un merge en master.</p>
                <ul>Pasos para usar Stash:
                    <li>Primero, puedes realizar cualquier cambio en un documento y guardar los cambios.</li>
                    <li>Luego, usar el comando git stash, esto guardará tus cambios pendientes en un listado de WIP (Work in Process).</li>
                    <li>El listado lo puedes consultar usando git stash list</li>
                    <li>Para obtener los cambios pendientes, debes usar el comando git stash pop ¡OJO! esto lo debes realizar en la misma rama que estabas creando los cambios, ya que si haces pop en una rama diferente, puedes generar un conflicto.</li>
                    <li>Una alternativa para guardar tus cambios pendientes y visualizarlos sin tocar la rama master, es usa el comando git stash branch nombreRama esto creará automáticamente una nueva rama con los cambios que estaban en el stash</li>
                    <li>Eliminar un stash si deseas eliminar un stash, puedes usar el comando git stash drop esto eliminará el stash que tengas y dejará la versión original.</li>
                    <h3>Git Clean</h3>
                    <p>Este comando es utilizado para eliminar archivos que no forman parte de nuestro directorio de trabajo, archivos como .logs, resultados de una compilación, etc.</p>
                </ul>
            </div>
        </main>
        <footer class="footer">
            <div class="container">
                <p>Desarrollado con <i class="fas fa-heart"></i> por <a href="https://twitter.com/sarleydurango">Sarley Durango</a></p>
            </div>
        </footer>
        <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
        <script src="scripts/script.js"></script>
        
    </body>
</html>